
# 1. Implemented body rate control in C++.

  LOC: 110 - 112

  ```
  V3F I{Ixx, Iyy, Izz};
  momentCmd = I * kpPQR * (pqrCmd - pqr);
  ```


  1.4. Tuning:

    I've looked for kpPQR using bisectional search (doubled kpPQR to 46, 46, 10, than updated to 92, 92, 20 and so on).
    I found that the best values were: 82, 82, 18.

  1.5. Remaining Issue:

    The drone still falls down. t_set is 0.06 and 0.07.


# 2. Implement roll pitch control in C++.

  LOC: 142 - 156

  ```
  if (collThrustCmd > 0) {
    float c = -collThrustCmd / mass;

    float b_x_c_target = CONSTRAIN(accelCmd.x / c, -maxTiltAngle, maxTiltAngle);
    float b_y_c_target = CONSTRAIN(accelCmd.y / c, -maxTiltAngle, maxTiltAngle);

    float b_x_c_dot = kpBank * (b_x_c_target - R[2]);
    float b_y_c_dot = kpBank * (b_y_c_target - R[5]);

    pqrCmd.x = (R[3] * b_x_c_dot - R[0] * b_y_c_dot) / R[8];
    pqrCmd.y = (R[4] * b_x_c_dot - R[1] * b_y_c_dot) / R[8];
    pqrCmd.z = 0.f;
  } else {
    pqrCmd = V3F(0.f, 0.f, 0.f);
  }
  ```

  I couldn't find a built-in matrix multiplication function, so I derived the p and q formulas manually from matrix multiplication.
  Increasing kpBank up to 6 helped to slightly improve results. The drone stays stable and achieves the target roll and omega around 0.12 and 0.075.
  After tuning kpPQR down to 74, the drone worked earlier at 0.07 and 0.08.


# 3. Implement altitude controller in C++.

  LOC: 188 - 194

  ```
  integratedAltitudeError += dt * (posZCmd - posZ);

  accelZCmd += kpPosZ * (posZCmd - posZ) + kpVelZ * (velZCmd - velZ) + KiPosZ * integratedAltitudeError;

  float descentRate = CONSTRAIN(CONST_GRAVITY - accelZCmd, -maxAscentRate/dt, maxDescentRate/dt);

  thrust = descentRate * mass / R[8];
  ```

  Just a regular feedforward PID controller.


# 4. Implement lateral position control in C++.

  LOC: 232 - 240
  
  ```
  if (velCmd.mag() > maxSpeedXY) {
    velCmd = velCmd.norm() * maxSpeedXY;
  }

  accelCmd += kpPosXY * (posCmd - pos) + kpVelXY * (velCmd - vel);

  if (accelCmd.mag() > maxAccelXY) {
    accelCmd = accelCmd.norm() * maxAccelXY;
  }
  ```

  Regular PD controller.
  It was quite tricky to find a way to limit the velocity and acceleration.
  Not sure what is the right max to use the horizontal velocity - velCmd.mag() or velCmd.magXY().


  3-4. Tuning:

  kpPosZ: Adjusting this up to 64 had no effect.
  kpPosXY: Doubling this to 8 helped to settle the drone, and further increases led to oscillation.
  kpVelXY: Increasing this to 16 reduced overshooting. I came back to tuning the previous kpPosXY.

  The optimal values were:

  ```
  kpPosXY = 30
  kpPosZ = 30
  kpVelXY = 12
  kpVelZ = 12
  ```
  
  A hint I found was incorrectâ€”the proportions should be reversed.


# 5. Implement yaw control in C++.

  LOC: 263 - 271

  ```
  float yawError = fmodf(yawCmd - yaw, 2.0f * M_PI);

  if (yawError > M_PI) {
    yawError -= 2.0f * M_PI;
  } else if (yawError < -M_PI) {
    yawError += 2.0f * M_PI;
  }

  yawRateCmd = kpYaw * yawError;
  ```

  kpYaw values above 4 caused oscillations. 
  Tunning 3rd argument of kpPQR didn't help to fix the oscillations.
  Lowering it to 10 helped to settle the drone faster.


# 6. Implement calculating the motor commands given commanded thrust and moments in C++.

  LOC: 75 - 85

  ```
  float l = L / sqrtf(2.f);

  float collectiveThrust = collThrustCmd;
  float rollMoment = momentCmd.x / l;
  float pitchMoment = momentCmd.y / l;
  float yawMoment = momentCmd.z / kappa;

  cmd.desiredThrustsN[0] = (collectiveThrust + rollMoment + pitchMoment - yawMoment) / 4.f;
  cmd.desiredThrustsN[1] = (collectiveThrust - rollMoment + pitchMoment + yawMoment) / 4.f;
  cmd.desiredThrustsN[2] = (collectiveThrust + rollMoment - pitchMoment + yawMoment) / 4.f;
  cmd.desiredThrustsN[3] = (collectiveThrust - rollMoment - pitchMoment - yawMoment) / 4.f;
  ```

  6.1. Coding:

    Each arm is always at 45 degrees relative to each axis so the distance from propeller to the axis is:

    float l = L / sqrtf(2.f);

    The moment generated by the propeller is directed opposite of its rotation and is proportional to the square of the angular velocities.

    Based on the following 3 equations given in the lab:

    ```
    f_total = F1 + F2 + F3 + F4
    moment_x = (F1 + F4 - F2 - F3) * l
    moment_y = (F1 + F2 - F3 - F4) * l
    ```

    And using:

    ```
    moment_z = tau1 + tau2 + tau3 + tau4
    tau1 =  -k_m * w0**2
    tau2 =  k_m * w1**2
    tau3 =  -k_m * w2**2
    tau4 =  k_m * w3**2
    ```

    We can rewrite moment_z as:

    ```
    moment_z * kf / km = (-k_m * w0**2 + k_m * w1**2 - k_m * w2**2 + k_m * w3**2) * kf / km
    moment_z / kappa = -f1 + f2 - f3 + f4;
    ```

    From this, we derive the thrust for each rotor:

    ```
    f1 + f2 + f3 + f4 = collectiveThrust
    f1 + f4 - f2 - f3 = momentCmd.x / l
    f1 + f2 - f3 - f4 = momentCmd.y / l
    -f1 + f2 - f3 + f4 = momentCmd.z / kappa
    ```

    Thus, the rotor thrusts are:

    ```
    f1 = (collectiveThrust + momentCmd.x / l + momentCmd.y / kappa - momentCmd.z / l) / 4
    f2 = (collectiveThrust - momentCmd.x / l + momentCmd.y / kappa + momentCmd.z / l) / 4
    f3 = (collectiveThrust - momentCmd.x / l - momentCmd.y / kappa - momentCmd.z / l) / 4
    f4 = (collectiveThrust + momentCmd.x / l - momentCmd.y / kappa + momentCmd.z / l) / 4
    ```

  6.2. Initial Tuning and Error:

    After tuning kpPQR, I didn't observe the expected results.
    I've looked through the Knowledge Q & A found that the formulas for f3 and f4 were incorrect and needed to be swapped:

    ```
    f3 = (collectiveThrust + momentCmd.x / l - momentCmd.y / kappa + momentCmd.z / l) / 4
    f4 = (collectiveThrust - momentCmd.x / l - momentCmd.y / kappa - momentCmd.z / l) / 4
    ```

  PS Would be greatful for some explanation why library formulas are different the ones in the project.


# 7. Your C++ controller is successfully able to fly the provided test trajectory and visually passes inspection of the scenarios leading up to the test trajectory.

All pass.
