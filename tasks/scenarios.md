
# 1. Intro

Upon launching the drone, it initially fell to the ground. To troubleshoot, I modified the parameters:

    I doubled the drone's mass from 0.4 to 0.8, and the drone ascended.
    Reducing the mass to 0.6 still resulted in ascent.
    Setting it to 0.5 kept the drone stable.

Pass

Conclusion: mass higher than the real makes the drone ascend due to increased commanded acceleration and vice versa.

# 2.1. Body Rate Control

2.1.1. Generating Motor Commands:

    Each arm is always at 45 degrees relative to each axis so the distance from propeller to the axis is:

    float l = L / sqrtf(2.f);

    The moment generated by the propeller is directed opposite of its rotation and is proportional to the square of the angular velocities.

    Based on the following 3 equations given in the lab:

    ```
    f_total = F1 + F2 + F3 + F4
    moment_x = (F1 + F4 - F2 - F3) * l
    moment_y = (F1 + F2 - F3 - F4) * l
    ```

    And using:

    ```
    moment_z = tau1 + tau2 + tau3 + tau4
    tau1 =  -k_m * w0**2
    tau2 =  k_m * w1**2
    tau3 =  -k_m * w2**2
    tau4 =  k_m * w3**2
    ```

    We can rewrite moment_z as:

    ```
    moment_z * kf / km = (-k_m * w0**2 + k_m * w1**2 - k_m * w2**2 + k_m * w3**2) * kf / km
    moment_z / kappa = -f1 + f2 - f3 + f4;
    ```

    From this, we derive the thrust for each rotor:

    ```
    f1 + f2 + f3 + f4 = collectiveThrust
    f1 + f4 - f2 - f3 = momentCmd.x / l
    f1 + f2 - f3 - f4 = momentCmd.y / l
    -f1 + f2 - f3 + f4 = momentCmd.z / kappa
    ```

    Thus, the rotor thrusts are:

    ```
    f1 = (collectiveThrust + momentCmd.x / l + momentCmd.y / kappa - momentCmd.z / l) / 4
    f2 = (collectiveThrust - momentCmd.x / l + momentCmd.y / kappa + momentCmd.z / l) / 4
    f3 = (collectiveThrust - momentCmd.x / l - momentCmd.y / kappa - momentCmd.z / l) / 4
    f4 = (collectiveThrust + momentCmd.x / l - momentCmd.y / kappa + momentCmd.z / l) / 4
    ```
  
2.1.2. Body Rate Control Logic:

  Body rate control follows the straightforward logic:

  ```
  V3F I{Ixx, Iyy, Izz};
  momentCmd = I * kpPQR * (pqrCmd - pqr);
  ```


2.1.3. Initial Tuning and Error:

  After tuning kpPQR, I didn't observe the expected results.
  I've looked through the Knowledge Q & A found that the formulas for f3 and f4 were incorrect and needed to be swapped:

  ```
  f3 = (collectiveThrust + momentCmd.x / l - momentCmd.y / kappa + momentCmd.z / l) / 4
  f4 = (collectiveThrust - momentCmd.x / l - momentCmd.y / kappa - momentCmd.z / l) / 4
  ```

  PS Would be greatful for some explanation why library formulas are different the ones in the project.

2.1.4. Successful Tuning:

  I've looked for kpPQR using bisectional search (doubled kpPQR to 46, 46, 10, than updated to 92, 92, 20 and so on).
  I found that the best values were: 82, 82, 18.

2.1.5. Remaining Issue:

  The drone still falls down. t_set is 0.06 and 0.07.


# 2.2. Roll / Pitch Control

  I couldn't find a built-in matrix multiplication function, so I derived the p and q formulas manually from matrix multiplication.
  Increasing kpBank up to 6 helped to slightly improve results. The drone stays stable and achieves the target roll and omega around 0.12 and 0.075.
  After tuning kpPQR down to 74, the drone worked earlier at 0.07 and 0.08.


# 3. Position, Velocity, and Yaw Control

3.1. Lateral Position Control:

  This is a simple PD controller:

  ```
  accelCmd += kpPosXY * (posCmd - pos) + kpVelXY * (velCmd - vel);
  ```

  It was quite tricky to find a way to limit the velocity and acceleration.
  Not sure what is the right max to use the horizontal velocity - velCmd.mag() or velCmd.magXY().

3.2. Altitude Control:
  This is a simple feedforward PID controller.

3.3. Tuning:
  kpPosZ: Adjusting this up to 64 had no effect.
  kpPosXY: Doubling this to 8 helped to settle the drone, and further increases led to oscillation.
  kpVelXY: Increasing this to 16 reduced overshooting. I came back to tuning the previous kpPosXY.

  The optimal values were:

  ```
  kpPosXY = 30
  kpPosZ = 30
  kpVelXY = 12
  kpVelZ = 12
  ```
  
  A hint I found was incorrectâ€”the proportions should be reversed.

3.4. Yaw Control:

  kpYaw values above 4 caused oscillations. 
  Tunning 3rd argument of kpPQR didn't help to fix the oscillations.
  Lowering it to 10 helped to settle the drone faster.


# 4. Non-idealities and robustness

  The green drone had roll-pitch issues, so I increased kpBank to 16.
  All three drones converged slowly horizontally, so I decreased kpVelXY and kpPosXY to 10 and 27, respectively.
  The red drone settled vertically too slow, so I reduced kpVelZ to 6. Adjusting kpPosZ had no effect.

# 5. Tracking trajectories

  Follows the trajectory perfectly.

# 6. Extra Challenge 1:

  Did the velocity-specified trajectory make a difference? Why?

  Yes, it significantly improved performance by reducing the "D" error in both the Altitude and LateralPosition controllers. This resulted in more accurate commanded acceleration:

  ```
  accelZCmd += kpPosZ * (posZCmd - posZ) + kpVelZ * (velZCmd - velZ) + KiPosZ * integratedAltitudeError
  accelCmd += kpPosXY * (posCmd - pos) + kpVelXY * (velCmd - vel);
  ```

# 7. Extra Challenge 2:

  I increased speed by multiplying the x, y, z position angles by 3 instead of 2:

  ```
  x = math.sin(t * 3 * math.pi / period[0] + phase[0]) * radius * amp[0] + center[0];
  y = math.sin(t * 3 * math.pi / period[1] + phase[1]) * radius * amp[1] + center[1];
  z = math.sin(t * 3 * math.pi / period[2] + phase[2]) * radius * amp[2] + center[2];
  ```

  Increasing velocity control gains reduced overshooting but the drone still strayed far from the desired trajectory.

  In summary, drone behavior depends heavily on the configuration, whether the focus is on velocity, acceleration, or another factor.
